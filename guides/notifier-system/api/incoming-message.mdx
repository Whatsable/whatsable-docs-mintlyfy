---
title: 'Incoming Messages'
description: 'Receive and manage real-time WhatsApp message notifications via webhooks'
icon: 'inbox'
---

<Tip>
Incoming message webhooks deliver real-time notifications when your recipients reply, enabling immediate responses and interactive conversations through WhatsApp.
</Tip>

The Incoming Messages system provides a robust webhook infrastructure that enables your application to receive and process WhatsApp messages from your recipients in real-time. This guide covers how to configure, manage, and handle incoming message webhooks.

## Overview

Webhooks are HTTP callbacks that deliver notifications to your server whenever specific events occur - in this case, when recipients reply to your WhatsApp messages. Benefits include:

- **Real-time processing** of customer responses
- **Seamless integration** with your existing systems
- **Automated workflows** triggered by customer messages
- **Enhanced customer experience** through timely interactions

<Card title="Try it in the API Reference" icon="arrow-right" href="https://docs.whatsable.app/api-reference/notifier-system/webhooks/manage-webhooks">
  Explore the Webhook Management API and start receiving incoming messages
</Card>

## Webhook Configuration

### Managing Endpoints

<Steps>
  <Step title="Access Webhook Settings">
    Navigate to the Developer section in your dashboard sidebar to manage webhook configurations.
  </Step>
  <Step title="Configure Endpoint">
    Add a new webhook URL where you want to receive incoming message notifications.
  </Step>
  <Step title="Set Up Authentication">
    We recommend implementing signature verification to ensure webhook security.
  </Step>
  <Step title="Test Your Endpoint">
    Use the test feature to verify your webhook is properly receiving and processing events.
  </Step>
</Steps>

### Endpoint Requirements

<Warning>
All webhook endpoints must be publicly accessible via HTTPS and configured to accept POST requests with JSON payloads. HTTP endpoints are not supported in production environments.
</Warning>

Your webhook endpoint must:

1. Accept HTTP POST requests
2. Process JSON payloads
3. Return a 2xx status code within 10 seconds
4. Implement idempotency handling (see best practices below)

## Webhook Payload

When a user replies to your WhatsApp message, we'll send a POST request to your configured endpoint with a detailed payload.

### Sample Payload

<CodeGroup>
```json Incoming Text Message
{
  "last_messages": [
    {
      "type": "user",
      "content": "Thank you for the quick response. Can you provide more details about your premium service plans?",
      "timestamp": "2025-06-09T22:08:11.990Z",
      "content_type": "text"
    },
    {
      "type": "bot",
      "content": "I'd be happy to help you explore our premium service options. Let me connect you with a specialist who can provide detailed information.",
      "timestamp": "2025-06-09T21:45:30.417Z",
      "content_type": "text"
    }
  ],
  "conversation_paragraph": "User (10:08:11 PM): Thank you for the quick response. Can you provide more details about your premium service plans? ; Bot (9:45:30 PM): I'd be happy to help you explore our premium service options. Let me connect you with a specialist who can provide detailed information.",
  "phone_number": "14155552671",
  "recipient_name": "Sarah Johnson",
  "user_id": "9232fcef-a570-4a2c-b46b-6cab53aec304",
  "last_message_of_user": "Thank you for the quick response. Can you provide more details about your premium service plans?",
  "last_message_of_bot": "I'd be happy to help you explore our premium service options. Let me connect you with a specialist who can provide detailed information.",
  "message_type": "text",
  "user_last_message_time": 1749506891,
  "bot_last_message_time": 1749504330,
  "attachment_url": null,
  "note": "",
  "note_automation": "",
  "labels": "sales, premium-inquiry"
}
```

```json Incoming Media Message
{
  "last_messages": [
    {
      "type": "user",
      "content": "",
      "timestamp": "2025-06-09T14:05:12.000Z",
      "content_type": "document",
      "media_url": "https://api.insightssystem.com/vault/LSMumRx1/VR-1aHOci6nP28eHWHJH7JauJkc/Ew7R9w../contract_proposal_v2.pdf"
    },
    {
      "type": "bot",
      "content": "Please upload the signed contract document when ready, and I'll process it immediately.",
      "timestamp": "2025-06-09T14:03:20.000Z",
      "content_type": "text"
    }
  ],
  "conversation_paragraph": "User (2:05:12 PM): [Document] ; Bot (2:03:20 PM): Please upload the signed contract document when ready, and I'll process it immediately.",
  "phone_number": "14155552671",
  "recipient_name": "Sarah Johnson",
  "user_id": "9232fcef-a570-4a2c-b46b-6cab53aec304",
  "last_message_of_user": "",
  "last_message_of_bot": "Please upload the signed contract document when ready, and I'll process it immediately.",
  "message_type": "document",
  "user_last_message_time": 1749472312,
  "bot_last_message_time": 1749472200,
  "attachment_url": "https://api.insightssystem.com/vault/LSMumRx1/VR-1aHOci6nP28eHWHJH7JauJkc/Ew7R9w../contract_proposal_v2.pdf",
  "note": "",
  "note_automation": "",
  "labels": "contracts, document-processing"
}
```
</CodeGroup>

### Payload Fields

<ResponseField name="last_messages" type="array" required>
  Array containing the recent messages in the conversation
  <Expandable title="last_messages array">
    <ResponseField name="type" type="string" required>
      Sender type ("user" or "bot")
    </ResponseField>

    <ResponseField name="content" type="string">
      Message content (empty for media messages)
    </ResponseField>

    <ResponseField name="timestamp" type="string" required>
      ISO 8601 timestamp when the message was sent
    </ResponseField>

    <ResponseField name="content_type" type="string" required>
      Type of content (text, image, audio, video, document, location)
    </ResponseField>

    <ResponseField name="media_url" type="string">
      URL to media file if applicable (valid for 24 hours)
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="conversation_paragraph" type="string" required>
  Human-readable summary of the recent conversation
</ResponseField>

<ResponseField name="phone_number" type="string" required>
  The phone number of the recipient who sent the message
</ResponseField>

<ResponseField name="recipient_name" type="string">
  The name of the recipient if available
</ResponseField>

<ResponseField name="user_id" type="string" required>
  Unique identifier for the user in your system
</ResponseField>

<ResponseField name="last_message_of_user" type="string">
  The last message sent by the user
</ResponseField>

<ResponseField name="last_message_of_bot" type="string">
  The last message sent by your system
</ResponseField>

<ResponseField name="message_type" type="string" required>
  The type of the latest message (text, image, audio, video, document, location)
</ResponseField>

<ResponseField name="user_last_message_time" type="integer" required>
  Unix timestamp of the user's last message
</ResponseField>

<ResponseField name="bot_last_message_time" type="integer" required>
  Unix timestamp of your system's last message
</ResponseField>

<ResponseField name="attachment_url" type="string">
  URL to media file if the latest message contains media (null for text messages)
</ResponseField>

<ResponseField name="note" type="string">
  Custom note field for additional context
</ResponseField>

<ResponseField name="note_automation" type="string">
  Automation-related notes
</ResponseField>

<ResponseField name="labels" type="string">
  Comma-separated labels for categorizing the conversation
</ResponseField>

## Webhook Management API

You can programmatically manage your webhook endpoints using our API.

### List Webhook Endpoints

Retrieve all configured webhook endpoints for your account.

<CodeGroup>
```bash cURL
curl -X GET \
  https://api.insightssystem.com/api:qh9OQ3OW/webhook/dev/create \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Bearer YOUR_API_KEY'
```

```javascript Node.js
const axios = require('axios');

async function listWebhooks() {
  try {
    const response = await axios.get(
      'https://api.insightssystem.com/api:qh9OQ3OW/webhook/dev/create',
      {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer YOUR_API_KEY'
        }
      }
    );
    console.log(response.data);
    return response.data;
  } catch (error) {
    console.error('Error listing webhooks:', error);
  }
}

listWebhooks();
```

```python Python
import requests

url = "https://api.insightssystem.com/api:qh9OQ3OW/webhook/dev/create"

headers = {
    "Content-Type": "application/json",
    "Authorization": "Bearer YOUR_API_KEY"
}

response = requests.get(url, headers=headers)
print(response.json())
```
</CodeGroup>

### Create Webhook Endpoint

Register a new webhook endpoint to receive incoming message notifications.

<CodeGroup>
```bash cURL
curl -X POST \
  https://api.insightssystem.com/api:qh9OQ3OW/webhook/dev/create \
  -H 'Content-Type: application/json' \
  -H 'Authorization: Bearer YOUR_API_KEY' \
  -d '{
    "url": "https://your-domain.com/api/webhooks/whatsapp",
    "description": "Production webhook endpoint for WhatsApp message notifications",
    "events": ["incoming_message"]
  }'
```

```javascript Node.js
const axios = require('axios');

async function createWebhook() {
  try {
    const response = await axios.post(
      'https://api.insightssystem.com/api:qh9OQ3OW/webhook/dev/create',
      {
        url: "https://your-domain.com/api/webhooks/whatsapp",
        description: "Production webhook endpoint for WhatsApp message notifications",
        events: ["incoming_message"]
      },
      {
        headers: {
          'Content-Type': 'application/json',
          'Authorization': 'Bearer YOUR_API_KEY'
        }
      }
    );
    console.log(response.data);
    return response.data;
  } catch (error) {
    console.error('Error creating webhook:', error);
  }
}

createWebhook();
```

```python Python
import requests

url = "https://api.insightssystem.com/api:qh9OQ3OW/webhook/dev/create"

headers = {
    "Content-Type": "application/json",
    "Authorization": "Bearer YOUR_API_KEY"
}

data = {
    "url": "https://your-domain.com/api/webhooks/whatsapp",
    "description": "Production webhook endpoint for WhatsApp message notifications",
    "events": ["incoming_message"]
}

response = requests.post(url, headers=headers, json=data)
print(response.json())
```
</CodeGroup>

<Warning>
Always verify webhook signatures to ensure the authenticity of incoming requests. This prevents malicious actors from sending fraudulent events to your endpoint.
</Warning>

## Best Practices

<CardGroup cols={2}>
  <Card title="Idempotency" icon="rotate">
    Implement idempotency key checks to prevent duplicate processing of events. Use the combination of `user_id` and `user_last_message_time` fields to detect and handle retries.
  </Card>
  <Card title="Graceful Error Handling" icon="shield-check">
    Design your webhook handler to gracefully process unexpected payload structures or event types. This ensures compatibility with future API updates.
  </Card>
  <Card title="Quick Response" icon="bolt">
    Always respond quickly with a 2xx status code, then process the webhook asynchronously. Responses taking longer than 10 seconds may cause webhook delivery retries.
  </Card>
  <Card title="Multiple Endpoints" icon="network-wired">
    Consider configuring multiple webhook endpoints for different environments (development, staging, production) or different types of processing.
  </Card>
</CardGroup>

### Handling Media Files

When receiving media messages:

1. Download the media file from the `attachment_url` or `media_url` provided in the webhook as soon as possible
2. Media URLs expire after 24 hours
3. Store media files securely in your system

<CodeGroup>
```javascript Node.js
const axios = require('axios');
const fs = require('fs');
const path = require('path');

async function downloadMedia(mediaUrl) {
  try {
    // Download the media file with appropriate headers
    const response = await axios({
      method: 'GET',
      url: mediaUrl,
      responseType: 'arraybuffer',
      timeout: 30000, // 30 second timeout
      headers: {
        'User-Agent': 'WhatsApp-Webhook-Client/1.0'
      }
    });
    
    // Generate secure filename with timestamp
    const fileBuffer = Buffer.from(response.data);
    const fileExtension = path.extname(new URL(mediaUrl).pathname) || '.bin';
    const filename = `media_${Date.now()}_${Math.random().toString(36).substr(2, 9)}${fileExtension}`;
    
    // Ensure media directory exists
    const mediaDir = './media_files';
    if (!fs.existsSync(mediaDir)) {
      fs.mkdirSync(mediaDir, { recursive: true });
    }
    
    const filePath = path.join(mediaDir, filename);
    fs.writeFileSync(filePath, fileBuffer);
    
    return filePath;
  } catch (error) {
    console.error('Media download error:', error.message);
    throw new Error(`Failed to download media: ${error.message}`);
  }
}

// Example webhook handler for media messages
app.post('/api/webhooks/whatsapp', express.json(), async (req, res) => {
  const payload = req.body;
  
  // Handle media messages with attachments
  if (payload.message_type !== 'text' && payload.attachment_url) {
    try {
      const savedFile = await downloadMedia(payload.attachment_url);
      console.log(`Media file processed successfully: ${savedFile}`);
      
      // Additional processing logic for media files
      await processMediaFile(savedFile, payload.message_type);
      
    } catch (error) {
      console.error('Media processing failed:', error);
      // Implement appropriate error handling
    }
  }
  
  // Process text messages
  if (payload.message_type === 'text') {
    await processTextMessage(payload);
  }
  
  res.status(200).json({ 
    status: 'received', 
    message: 'Webhook processed successfully' 
  });
});
```

```python Python
import requests
import os
import time
from urllib.parse import urlparse

def download_media(media_url):
    try:
        # Download the media file with appropriate headers
        response = requests.get(
            media_url, 
            timeout=30,  # 30 second timeout
            headers={'User-Agent': 'WhatsApp-Webhook-Client/1.0'}
        )
        response.raise_for_status()
        
        # Generate secure filename with timestamp
        file_data = response.content
        file_extension = os.path.splitext(urlparse(media_url).path)[1] or '.bin'
        filename = f"media_{int(time.time())}_{secrets.token_hex(4)}{file_extension}"
        
        # Ensure media directory exists
        media_dir = './media_files'
        os.makedirs(media_dir, exist_ok=True)
        
        file_path = os.path.join(media_dir, filename)
        with open(file_path, 'wb') as f:
            f.write(file_data)
        
        return file_path
    except Exception as e:
        print(f"Media download error: {e}")
        raise Exception(f"Failed to download media: {e}")

# Example webhook handler for media messages
@app.route('/api/webhooks/whatsapp', methods=['POST'])
def handle_webhook():
    payload = request.json
    
    # Handle media messages with attachments
    if payload.get('message_type') != 'text' and payload.get('attachment_url'):
        try:
            saved_file = download_media(payload['attachment_url'])
            print(f"Media file processed successfully: {saved_file}")
            
            # Additional processing logic for media files
            process_media_file(saved_file, payload['message_type'])
            
        except Exception as e:
            print(f"Media processing failed: {e}")
            # Implement appropriate error handling
    
    # Process text messages
    if payload.get('message_type') == 'text':
        process_text_message(payload)
    
    return jsonify({
        'status': 'received', 
        'message': 'Webhook processed successfully'
    }), 200
```
</CodeGroup>

## Rate Limiting and Quotas

<AccordionGroup>
  <Accordion title="Webhook Delivery Attempts">
    If your endpoint fails to respond with a 2xx status code, we'll retry delivery using an exponential backoff strategy: 5s, 30s, 2m, 10m, 30m, 2h, 6h, 12h up to 3 days.
  </Accordion>
  <Accordion title="Endpoint Performance">
    Your endpoint should respond within 10 seconds. If it takes longer, we may time out and retry the delivery.
  </Accordion>
  <Accordion title="Concurrency Limits">
    We may send up to 25 concurrent webhook requests to a single endpoint. Design your system to handle this level of concurrency.
  </Accordion>
</AccordionGroup>

## Testing Webhooks

Test your webhook implementation before going live:

1. Create a test webhook endpoint using a service like [webhook.site](https://webhook.site/) or [RequestBin](https://requestbin.com/)
2. Configure this test URL in your webhook settings through the developer dashboard
3. Send a test WhatsApp message to trigger the webhook delivery
4. Inspect the received payload to verify the data structure matches your expectations
5. Implement comprehensive handling in your application with proper error management

<Warning>
Always test your webhook implementation thoroughly in a development environment before configuring production endpoints.
</Warning>

## Troubleshooting

<AccordionGroup>
  <Accordion title="Webhook Not Receiving Events">
    - Verify your endpoint is publicly accessible
    - Check for HTTP 4xx or 5xx responses
    - Ensure proper SSL certificate configuration
    - Verify your webhook is enabled in the dashboard
  </Accordion>
  <Accordion title="Invalid Signature Errors">
    - Confirm you're using the correct webhook secret
    - Ensure you're using the raw request body for signature calculation
    - Check that you're using HMAC-SHA256 for verification
    - Verify your implementation handles base64 or hex encoding correctly
  </Accordion>
  <Accordion title="Missing Media Files">
    - Media URLs expire after 24 hours
    - Download and store media files immediately
    - Check for proper handling of MIME types
    - Verify network connectivity to the media URL
  </Accordion>
  <Accordion title="Duplicate Event Processing">
    - Implement idempotency using the combination of `user_id` and `user_last_message_time`
    - Store processed event IDs in a persistent database
    - Add timeout logic to your idempotency check
  </Accordion>
</AccordionGroup>

## FAQs

<AccordionGroup>
  <Accordion title="Can I receive notifications for all WhatsApp account events?">
    Currently, webhooks are available for incoming messages only. We're working on expanding support for additional event types like delivery receipts, read receipts, and account status changes.
  </Accordion>
  <Accordion title="How do I handle different message types?">
    Check the `message_type` field in the webhook payload to determine the message type (text, image, audio, video, document, location) and process accordingly.
  </Accordion>
  <Accordion title="Do I need to respond to every webhook request?">
    Yes, your endpoint must respond with a 2xx HTTP status code for every webhook request to acknowledge receipt. This prevents unnecessary retries.
  </Accordion>
  <Accordion title="How can I test webhook delivery?">
    Use the "Test Webhook" feature in the Developer section of your dashboard to send a sample webhook payload to your endpoint.
  </Accordion>
</AccordionGroup>

<Card title="Need assistance?" icon="headset" href="mailto:support@whatsable.app">
  Our technical support team is available to assist with webhook configuration, payload handling, and integration questions
</Card>